from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .v2s_model import Vensim2StanCodeHandler
    from .vensim_model import VensimModelContext

from .vensim_ast_walker import FindRHSVariablesWalker
from .utilities import IndentedString, StatementTopoSort, vensim_name_to_identifier


class StanFunctionBuilder:
    r"""
    `StanFunctionBuilder` handles building the function stan file. The Stan portion of Stanify has the following
    hierarchy:
    - `functions.stan`: This holds the ODE target function. In short, this is your Vensim model translated into Stan.
    The ODE function is used in both $p(\tilde{\theta} | y)$(called `data2draws` in Stanify terminology) and
    $p(y | \theta)$(`draws2data`)
    - `draws2data.stan`: This is the first stage of the SBC process. It draws samples from the prior, which is then used to
    generate data samples. For those who are familiar with Bayesian stats, it's doing a prior predictive simulation.
    This is represented as:
    $$
    \begin{aligned}
    \theta &\sim p(\theta) \\\
    \y &\sim p(y | \theta)
    \end{aligned}
    $$
    - `data2draws.stan`: This is the second stage of SBC, which fits $\tilde{\theta}$ with the data generated from
    `draws2data`. For SBC, we now compare the single draw from the prior($\tilde$), with **draws** of the fit
    ($\tilde{\theta}$), enabling us to compute for example, rank statistics.

    Attributes
    ----------
    stan_initialized_variables : set[str]
       Holds the names of variables which are present in the Vensim model, but the user has defined V2S code that defines
       the alternative expression to use. This means the Vensim code that defines the variable is not transpiled. In
       addition, since the variable gets declared within stan it must be passed into the ODE function as one of its
       parameters.
    _code : IndentedString
        Holds the generated code for the functions block. Use the property method `code` to access the code string

    Methods
    -------
    generate_functions_code()
        Generates and returns the code for `functions.stan`. Calls `generate_datafunctions_code` and
        `generate_odefunction_code`
    generate_datafunctions_code()
        Creates code for data functions
    generate_odefunction_code()
        Creates code for the ODE function.
    code()
        Property method for accessing the generated code string.
    """
    def __init__(self, v2s_code_handler: Vensim2StanCodeHandler, vensim_model_context: VensimModelContext):
        """

        Parameters
        ----------
        v2s_code_handler : Vensim2StanCodeHandler
            `v2s_model.Vensim2StanCodeHandler`
        vensim_model_context : VensimModelContext
            `vensim_model.VensimModelContext`
        """
        self.v2s_code_handler = v2s_code_handler
        self.vensim_model_context = vensim_model_context
        self.stan_initialized_variables: set[str] = set()
        self._code = IndentedString()

        # Find variables present in the V2S code and the vensim model
        for vensim_variable_name in self.vensim_model_context.variables.keys():
            if vensim_variable_name in self.v2s_code_handler.declared_variables:
                if vensim_variable_name in self.vensim_model_context.integ_outcome_variables:
                    # If it's a stock variable it can't be overriden
                    continue

                self.stan_initialized_variables.add(vensim_variable_name)

        # Initialize the statement topological sorter
        # If any Vensim variables have a prior assigned to them - it means it's generated by draws from the Stan model.
        # So we don't have to consider them when we're sorting the statements, nor generate code for them.
        self.statement_sorter = StatementTopoSort(tuple(self.stan_initialized_variables))

        # Iterate through the Vensim AST and populate the dependency graph
        walker = FindRHSVariablesWalker()
        for element in self.vensim_model_context.first_section.elements:
            lhs_variable = element.name
            for component in element.components:
                rhs_variables = walker.walk(component.ast)

                self.statement_sorter.add_stmt(lhs_variable, rhs_variables)

    def generate_functions_code(self) -> None:
        self._code += "functions {\n"
        self._code.indent_level += 1
        #code += self.generate_datafunctions_code()
        self._code += self.generate_odefunction_code()
        self._code.indent_level -= 1
        self._code += "}\n"

    @property
    def code(self) -> str:
        return str(self._code)

    def generate_odefunction_code(self) -> str:
        # sort the AST elements according to the sorted order
        statement_eval_order = self.statement_sorter.sort()
        elements = [element for element in self.vensim_model_context.first_section.elements if vensim_name_to_identifier(element.name) in statement_eval_order]

        elements = sorted(elements, key=lambda x: statement_eval_order.index(vensim_name_to_identifier(x.name)))

        self._code += f"vector ode_func(real time, vector outcome"

    def generate_datafunctions_code(self) -> str:
        """
        Generate code for the data functions.

        Returns
        -------
        a code string
        """
        pass


